<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="overview/overview.html"><strong aria-hidden="true">1.</strong> Hello Rust</a></li><li><a href="hello-cargo/hello-cargo.html"><strong aria-hidden="true">2.</strong> Hello Cargo</a></li><li><a href="values-primitive-types-println/values-primitive-types-println.html"><strong aria-hidden="true">3.</strong> Values, primitive type, println!</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>Ahhh, mà lỡ click vào rồi...</p>
<a class="header" href="#a-rồi-nói-gì-nói-đi" id="a-rồi-nói-gì-nói-đi"><h2>– Rồi nói gì nói đi:</h2></a>
<ul>
<li>Nói một chút về cái topic này: nó là mở đầu cho series học Rust dzí tui, được truyền cảm hứng từ 2 topics của boss Đạt: <a href="https://daynhauhoc.com/t/khuyen-khich-moi-nguoi-nen-hoc-ngon-ngu-lap-trinh-moi/71928">Khuyến khích mọi người nên học NNLT mới</a> và <a href="https://daynhauhoc.com/t/golang-bai-1-tour-of-go-hello-world/71940">Series học GoLang của anh Đạt</a> nên mình sẽ viết một series về ngôn ngữ lập trình Rust – một NNLT mà hiện tại mình cực kỳ thích (và <strong>rất</strong> lâu rồi chưa viết gì với cũng rớt hạng mất tiêu rồi :'( ). Bản thân mình đánh giá Rust rất đáng học (dĩ nhiên là vậy rồi :joy: không phải thì bỏ công ra viết làm gì?). Trang chủ của RustLang: https://www.rust-lang.org/vi-VN/. Mình muốn Rust được nhiều sự chú ý mà nó đáng ra phải có :hand_splayed:.</li>
<li>Series này hướng đến mục tiêu là nắm được cơ bản về Rust.</li>
<li>Với tư cách là <strong>người cùng học</strong> và là người đã học trước (cũng được mấy tháng rồi, không nhớ là bao lâu nữa, chắc nửa năm), mình sẽ học cùng bạn, hỗ trợ bạn, gợi ý hướng sửa, giải thích chỗ sai, chỉ dẫn tài liệu cho bạn, ... Nhưng với mình, <strong>không có chuyện mình viết code dùm bạn</strong>, kết quả là mình sẽ không rep post của bạn. Bạn học cho bản thân mà, tự sửa sai thì mới tiến bộ được. Lưu ý nữa: mình sẽ không là giáo viên của bạn (vì kinh nghiệm và trình độ của mình không phải thượng thừa với mình không có hứng thú nhận học sinh). Nói trước để các bạn không kỳ vọng quá nhiều.</li>
<li>Nếu trong quá trình học có gì cần giải đáp, hãy pm mình. Mình sẽ cố gắng trả lời. Mà trong diễn đàn cũng có vài bạn học Rust rồi này, mình để ý nà, nếu các bạn muốn đóng góp thì cứ nói, bảo đảm mình không có trả tiền cho đâu. Hehe.</li>
<li>Trong lúc viết bài, sai sót là không thể tránh khỏi. Mọi góp ý đều được chào đón!</li>
<li>Vì mình có lịch học (với hơi lười) :'( nên không có viết bài thường xuyên (dự kiến 1 tuần 1-2 bài), nếu bạn muốn có bài mới thì có thể inbox nhẹ nhàng nhắc nhở mình. Mình cảm ơn trước.</li>
</ul>
<a class="header" href="#a-Ờ-vậy-rồi-bạn-lấy-cái-gì-mà-viết" id="a-Ờ-vậy-rồi-bạn-lấy-cái-gì-mà-viết"><h2>– Ờ, vậy rồi bạn lấy cái gì mà viết:</h2></a>
<ul>
<li>
<p>Tài liệu! Tài liệu thì mình sẽ sử dụng kết hợp giữa kinh nghiệm của mình với:</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/stable/rust-by-example">Rust by examples</a>: Học Rust kết hợp với thực hành   online. Nếu bạn học một mình và cảm thấy khá là chán khi chỉ ngồi đọc docs và (có thể) phải loay hoay với việc cài đặt đủ thứ thì học ở trang này nhanh, gọn, lẹ.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/book/second-edition/index.html">The Rust Official Docs – Second Edition</a>: Trang chủ của ebook học Rust.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/std/">The Rust Standard Library</a>: Tài liệu cho thư viện chuẩn.</p>
</li>
<li>
<p><a href="https://docs.rs/">Docs.rs</a>: Trang tài liệu cho các thư viện (viết bằng Rust) khác.</p>
</li>
<li>
<p>Học cho đã cũng đừng quên chúng ta còn <a href="stackoverflow.com">stackoverflow.com</a> nhé ;)</p>
</li>
<li>
<p>Những trang khác:</p>
</li>
<li>
<p><a href="http://play.rust-lang.org/">Rust Playground</a>: bạn có thể test nhanh code trên trình duyệt.</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/nomicon/">The Rustonomicon</a>: Chuyên sâu về Rust (chắc là mình không viết bài về cái này đâu, ai thích thì có thể tham khảo, mình thấy nó cũng không khó hiểu gì lắm đâu).</p>
</li>
<li>
<p><a href="https://www.reddit.com/r/rust/">Rust Sụbrédđít</a>: the Rust Programming Language subreddit, nơi đây cập nhật tin tức đủ thứ về Rust :crab:</p>
</li>
<li>
<p>Còn nhiều nữa: <a href="https://users.rust-lang.org/">4rum cho Rust users</a>, <a href="https://internals.rust-lang.org/">Bàn tán về bản thân Rust</a>, ...</p>
</li>
<li>
<p>Vì mình không có ra bài thường xuyên nên các bạn có thể đọc tài liệu trước cũng được, hãy cảm thấy thoải mái khi gửi tin nhắn hỏi cho mình nhé, nhớ là <strong>đừng bảo mình viết code dùm</strong> nhé :joy: mình cho ăn bơ á. Lưu ý là các tài liệu được viết bằng tiếng Anh, nếu bạn &quot;không đọc được&quot; thì bạn có 2 lựa chọn: &quot;có gì to tát đâu :smirk:&quot; - Học tiếng  Anh luôn, mần gì cử;hoặc &quot;tui hổng thích ăn sung còn trên cây :relieved:&quot; - Đợi mình viết bài, hoặc chủ động đi hỏi (dĩ nhiên là lâu hơn).</p>
</li>
</ul>
<a class="header" href="#a-Ừhm-cũng-ổn-đấy-nói-nữa-đi" id="a-Ừhm-cũng-ổn-đấy-nói-nữa-đi"><h2>– Ừhm, cũng ổn đấy, nói nữa đi:</h2></a>
<ul>
<li>Rust cũng có các điểm thuận lợi và bất lợi. Ngay từ trang chủ, đập vào mắt là Rust:</li>
</ul>
<ol>
<li>Nhanh, Rust là ngôn ngữ biên dịch và không có GC (garbage collector: bộ dọn rác) như các ngôn ngữ thông dịch hay biên dịch (như Go) khác. Tốc độ thực tiệm cận với C/C++. Tham khảo chỉ mang tính tham khảo <a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/rust.html">the benchmarksgame</a>.</li>
<li>Move semantics (không biết dịch sao cho vừa lòng) và Guaranteed Memory Safety (đảm bảo an toàn bộ nhớ): nghĩa là khi một biến gán giá trị cho một biến khác thì cũng sẽ chuyển <em>quyền sở hữu</em> của nó cho biến đó, dĩ nhiên là nó không thể nào đọc/ghi được giá trị nữa. Thực tế: bạn không thể nào có quyển sách đó nếu bạn đã đưa nó cho người khác. Xét 2 ví dụ đơn giản giữa C++ và Rust (xem ở cuối section này).</li>
<li>Type inference: Rust compiler có khả năng suy luận ra kiểu của biến. Như ví dụ bên dưới: mình hoàn toàn bỏ qua được <code>Vec&lt;int&gt;</code> trong <code>let v: Vec&lt;int&gt; ...</code>, Rust compiler vẫn biết được kiểu của <code>v</code> là <code>Vec&lt;int&gt;</code>.</li>
<li>Prevent data races: Khi bạn sử dụng nhiều threads cùng đọc ghi đồng thời vào một vùng nhớ sẽ dẫn đến data races, Rust không cho phép điều này xảy ra. Ví dụ thực tế, cả lớp (các threads) cùng tự ý ghi vào bảng (vùng nhớ) thì sẽ dẫn đến một mớ hỗn độn, kết quả là dữ liệu bên trong vùng nhớ không còn chính xác nữa (bạn có thể tham khảo với từ khóa <code>data races là gì</code> với Google.</li>
<li>Rust hỗ trợ generics, pattern matching (powered by some functional programming languages). Rust code có thể gọi C code, có nghĩa là: bạn vẫn có thể dùng các thư viện có sẵn khác mà không cần phải đợi thư viện đó viết bằng Rust, và cũng như, bạn có thể viết các thư viện cho các ngôn ngữ khác như Python, Java, ... với native code.</li>
<li>Rust đi chung với toolchains rất hiệu quả. Chỉ với lệnh <code>cargo</code>, bạn chỉ cầm thêm tên thư viện vào file Cargo.toml của projet rồi chạy <code>cargo build --release</code> là nó sẽ làm từ A-Z cho bạn: tải thư viện, biên dịch, optimize luôn. Không có khó khăn gì ở đây hết!</li>
<li>Trình biên dịch của Rust cho ra lỗi rất hữu ích (hầu hết các trường hợp). Hữu ích đến nỗi, bạn có thể nhắm mắt làm theo hướng dẫn của trình biên dịch mà không cần dùng não. (Đùa thôi, bạn phải dùng não, nhưng đó cũng là sự thật của mình lúc mới học Rust).</li>
<li>Còn nữa ... (chừng nào nhớ ra với dịch được thì update tiếp :joy: )</li>
</ol>
<pre><code>// C++
#include &lt;iostream&gt;
#include &lt;vector&gt;
int main() {
   std::vector&lt;int&gt; v  = {0, 1, 2, 3};
   std::vector&lt;int&gt; v2 = v;
   std::cout &lt;&lt; &quot;v[1]: &quot; &lt;&lt; v[1] &lt;&lt; std::endl;
   return 0;
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   let v: Vec&lt;int&gt; = vec![0, 1, 2, 3];
   let v2 = v;
   println!(&quot;v[1]: {}&quot;, v[1]);
}
</code></pre></pre>
<p>Trong 2 ví dụ trên, C++ hoàn toàn có thể compile và chạy được nhưng Rust không cho phép compile vì sau khi gán, <code>v</code> không còn quyền truy cập tới vùng nhớ đó nữa.
Đây cũng là một trong các quy tắc nghiêm ngặt của Rust. Cũng vì các quy tắc đó làm cho chương trình của Rust xanh sạch đẹp và không có lỗi runtime.</p>
<ul>
<li>Rust cũng có nhiều điểm bất lợi, ý kiến riêng của mình:</li>
</ul>
<ol>
<li>Phức tạp: Rust đã phức tạp và cả phức tạp dần theo thời gian. Team Rust làm việc rất tâm huyết :triumph: ngôn ngữ ngày có nhiều cập nhật và đổi mới, mình nghĩ đây cũng là điểm mạnh và cũng là điểm yếu. Vì thay đổi quá nhiều dẫn đến ngôn ngữ &quot;không ổn định&quot;, các thư viện cũ sẽ gặp nhiều rắc rối nếu không được update thường xuyên (mặc dù đã có các tools. Bạn nên học dần để dễ dàng bắt kịp :3 Mình không cho là Rust khó học, Rust chỉ &quot;hơi&quot; phức tạp một xíu, concepts hơi lạ so với bạn một chút xíu và sẽ mất thời gian hơn một xíu nhưng cũng đáng mà :D</li>
<li>Mọi thứ cần rõ ràng: vì lý do rustc cũng chỉ là &quot;cái máy&quot; nên nó không thật sự linh hoạt. Code bạn viết ra cần  rõ ràng, đôi khi <strong>thứ tự khai báo biến</strong> cũng là nguyên nhân dẫn đến lỗi.</li>
<li>Có thể còn nhiều điểm yếu khác nữa mà mình chưa biết ...</li>
</ol>
<p>Chi tiết và sinh động hơn, các bạn hãy đọc bài của chú thefullsnack tại <a href="https://thefullsnack.com/posts/rust-intro.html">đây</a> (chú trả tiền cho con vì pr dùm chú đi :P ).</p>
<a class="header" href="#a-rồi-cài-đặt-sao" id="a-rồi-cài-đặt-sao"><h2>– Rồi cài đặt sao?</h2></a>
<p>Trang chủ đã hướng dẫn khá là rõ ràng, có cả tiếng Việt nữa: https://www.rust-lang.org/vi-VN/install.html
Đối với các bạn sử dụng *nix thì vẫn có các package riêng lẻ như rustc, cargo, ... mình thấy nó sẽ khá rối và update thì phải đợi mirror. Mình muốn đơn giản thì chỉ cần theo hướng dẫn là đủ. Nếu trong quá trình cài đặt xuất hiện lỗi thì bạn có thể reply post này, mình sẽ cố gắng hỗ trợ. (Mình không có lưu ý gì vì mình chưa cài lỗi bao giờ :smile:)</p>
<a class="header" href="#a-tui-thắc-mắc-cái-này-nè" id="a-tui-thắc-mắc-cái-này-nè"><h2>– Tui thắc mắc cái này nè:</h2></a>
<ol>
<li>Q: Kinh nghiệm kiểu abc, xyz,... như tui thì có học được không?
A: Muốn thì được hết. Nhưng có thể sẽ phức tạp hơn các ngôn ngữ bạn từng học nên cần thời gian. Vì phức tạp nên cũng dễ nản, chuyện đương nhiên mà! Nhưng đừng lo, nó sẽ đáng công sức bạn bỏ ra. Lý do? Nó :clap: sẽ :clap: không  :clap: bao :clap: giờ :clap: có :clap: Segmentation :clap: Fault!  :clap:</li>
<li>Q: Khoảng bao lâu thì tui sẽ nắm vững cơ bản như cú pháp?
A: Tùy vào mỗi người, một vài tuần gì đấy, mình đoán vậy. Chưa bao gồm thời gian học sử dụng macros (cái này nâng cao rồi :3 )</li>
<li>Q: Học Rust thì làm được gì?
A: Ừhm, C/C++ làm được gì thì Rust làm được cái đó! Như: games, browsers, OSes, websites, wasm apps, ... và hệ thống nhúng (Rust làm được nhưng chắc chưa bằng C được, mình không rõ mảng này cho lắm).</li>
<li>Q: So sánh Rust với ngôn ngữ X, Y, Z,... đi?
A: Bạn có thể tham khảo Google, cũng khá nhiều. Bản thân Rust phức tạp hơn (và phức tạp dần theo thời gian) so với hầu hết các ngôn ngữ phổ biến khác nên sẽ khó khăn cho nhiều người kể cả người có kinh nghiệm lập trình lâu năm. Nếu bạn chưa học lập trình bao giờ, hoàn toàn ổn nếu bạn chọn Rust là ngôn ngữ đầu tiên, nhưng nếu Rust là ngôn ngữ thứ 2 thì có vẻ căng đấy vì những khái niệm của Rust sẽ làm cho bạn rối với ngôn ngữ bạn vừa học (nếu bạn không bị rối thì quá tốt rồi :D ).</li>
<li>Q: Nói quá trời nói rồi công ty nào xài Rust?
A: Bạn có thể tìm thấy ở <a href="https://www.rust-lang.org/en-US/friends.html">đây</a>.</li>
<li>Q: Muốn coi thử một chương trình viết bằng Rust thì trông nó như thế nào?
A: Mình từng viết một cái <a href="https://daynhauhoc.com/t/i-challenge-dnh-to/56821/4">interpreter cho Brainf*ck bằng Rust</a> này. Vì mình muốn nó chạy nhanh một chút nên phải làm nhiều -&gt; dài. Sau khi học xong, bạn có thể viết 1 cái chẳng hạn :D Hay lớn hơn nữa không chừng?</li>
</ol>
<p>Hỏi thêm đi rồi mình sẽ update câu trả lời vào phần này, mình sẽ cố gắng trả lời trong giới hạn. Giờ thì mình mỏi tay quá rồi, khi khác gõ tiếp nhé :heart:</p>
<a class="header" href="#a-mở-đầu" id="a-mở-đầu"><h2>— Mở đầu</h2></a>
<p>Ngày hôm qua (<a href="https://daynhauhoc.com/t/cung%E2%80%94hoc%E2%80%94rust%E2%80%94ngay%E2%80%94thu%E2%80%940%E2%80%94hoc%E2%80%94hanh%E2%80%94gi%E2%80%94gio%E2%80%94nay/71992">ngày 0</a>), mình đã giới thiệu sơ lược về Rust, nếu bạn chưa nghe qua Rust thì có thể đọc lại. Lưu ý, các ví dụ mình sẽ viết trên Linux.
Ngày hôm nay, chúng ta sẽ học:</p>
<p>— Cấu trúc một chương trình &quot;Hello world!&quot; trên Rust.
— Làm quen với dòng lệnh: trình biên dịch rustc và công cụ quản lý dự án và thư viện — Cargo.</p>
<p>Yêu cầu:</p>
<p>— Biết sử dụng dòng lệnh cơ bản: bash hoặc cmd (như setup biến môi trường, sử dụng lệnh <code>cd</code>, ... vì sẽ rất mất thời gian nếu mình phải đào tạo cách sử dụng).
— Đã cài đặt thành công Rust (stable) 1.28 trên máy. Kiểm tra bằng cách gõ <code>rustc --version</code> vào cửa sổ dòng lệnh.</p>
<hr />
<a class="header" href="#a-hello-world-bằng-rust" id="a-hello-world-bằng-rust"><h2>— &quot;Hello world!&quot; bằng Rust?</h2></a>
<p>Một file mã nguồn của Rust có phần mở rộng là <code>.rs</code>. Gõ lại đoạn mã sau là lưu lại với tên bất kỳ cùng với <code>.rs</code> (<code>helloworld.rs</code> chẳng hạn). Rust có hỗ trợ trên vim, Sublime Text, VS Code,... Nếu bạn muốn mình chọn dùm, mình chọn Sublime Text với package Rust Enhanced (giúp bạn kiểm tra code khi save).
Nếu bạn chưa cài đặt Rust vào máy thì bạn cũng có thể truy cập play.rust-lang.org gõ lại đoạn mã sau vào.</p>
<pre><pre class="playpen"><code class="language-rust">// Đây là comment 1 dòng
/*
   Đây là comment nhiều dòng.
 */

fn main() {
    println!(&quot;Hello world!&quot;);
}
</code></pre></pre>
<p>Nếu bạn sử dụng Rust Playground thì chỉ cần nhấn Run thì chương trình sẽ được compile online và in dòng &quot;Hello world!&quot; ra màn hình. Rất đơn giản phải không nào? :joy:
Nếu bạn muốn compile offline (sẽ nói chi tiết hơn ở mục sau), mở cửa sổ dòng lệnh, hãy chắc ăn là thư mục làm việc hiện hành (current working directory) đang chứa file cần compile, rồi gõ <code>rustc helloworld.rs</code> (nếu bạn đã đặt tên nó là <code>helloworld.rs</code>). Sau đó chạy <code>./helloworld</code> (Linux) hoặc <code>.\helloworld.exe</code> (Windows). Kết quả cũng tương tự với cách trên.
Ta xét từng chi tiết của chương trình trên:</p>
<ul>
<li>Với comment, không còn gì rõ ràng hơn:</li>
<li><code>//</code>: sẽ đánh dấu nội dung phía sau là comment cho đến hết dòng.</li>
<li><code>/*</code>: sẽ đánh dấu nội dung phía sau là comment cho đến ghi gặp <code>*/</code>.</li>
<li>Các cú pháp comment có dạng <code>///</code> hay <code>//!</code> sẽ có thêm chức năng: dùng nội dung comments để tạo ra tài liệu cho thư viện/ứng dụng đó.</li>
<li>Một chương trình thực thi viết bằng Rust sẽ phải có hàm <code>main</code> (nếu là thư viện, hàm <code>main</code> là không cần thiết). Trong hàm <code>main</code> này:</li>
<li><code>fn</code>: là từ khóa bắt buộc (viết tắt: &quot;function&quot;).</li>
<li><code>main</code>:  là định danh, trường hợp này, cụ thể là tên hàm, được phép dùng các ký tự từ: a—z, A—Z, 0—9, _. Nhưng: không được bắt đầu bằng số, không sử dụng các ký tự non—ascii (không thuộc bảng mã ASCII, vì Rust chưa hỗ trợ hoàn thiện) hay chỉ dùng '_' (đây được gọi là định danh đặc biệt ('reserved identifier'). Những trường hợp định danh khác (tên biến,...) cũng tuân theo quy luật này.
<ul>
<li>Tên hợp lệ: SmileSweet, _sister_sadistic, sUrPrIsE69,...</li>
<li>Tên không hợp lệ: 0service, _, skrâtâ...</li>
</ul>
</li>
<li><code>()</code>: sau khi khai báo tên hàm, phần trong cặp ngoặc này sẽ chứa tên biến truyền vào. Hàm <code>main</code> luôn không có bất kỳ biến nào. Sau cặp ngoặc này sẽ khai báo kiểu trả về của hàm (chúng ta sẽ đi sâu vào ở các ngày tiếp theo).</li>
<li>Kiểu trả về: Nếu không chỉ định kiểu trả về, Rust mặc định trả về kiểu Unit <code>()</code> (không giống <code>void</code> trong C/C++). Hàm <code>main</code> có thể trả về kiểu khác: <code>Result&lt;()&gt;</code> nhưng chúng ta chưa đề cập phần này ở đây.</li>
<li><code>{}</code>: khối lệnh sẽ được đặt trong cặp ngoặc nhọn. Các biến được khởi tạo phạm vi (scope) này sẽ được <bold>tự động</bold> hủy khi ra khỏi scope.</li>
<li><code>;</code>: ký tự đánh dấu kết thúc lệnh. Lưu ý: trường hợp duy nhất không dùng <code>;</code> là khi rút ngắn cho lệnh <code>return</code> (sẽ đề cập sau).</li>
<li><code>println!</code>: là một <strong>macro</strong> (vì theo sau là dấu <code>!</code>), không nên nhầm lẫn với hàm (không được kết thúc với <code>!</code>). Hệ thống macro trong Rust cực kỳ mạnh mẽ và cũng khá khó (hơn nhiều so với C/C++), nên mình sẽ hướng dẫn sử dụng chứ không hướng dẫn cách viết macros.</li>
<li><code>&quot;...&quot;</code>: Rust sử dụng dấu ngoặc kép để đánh dấu chuỗi. Một chuỗi trong Rust <strong>luôn luôn</strong> là một <a href="https://vi.wikipedia.org/wiki/Unicode">chuỗi Unicode hợp lệ</a>. Nâng cao: vì lẽ đó, Rust không cho phép bạn đánh chỉ số của chuỗi như các ngôn ngữ lập trình phổ biến khác! Nhưng sẽ có cách khác để làm việc này. Sẽ đề cập sau :p</li>
</ul>
<p>Kết: Viết nhiều như thế nhưng có lẽ đa số các bạn đều đã biết hết rồi (vì phần này cũng không khác C/C++ gì cho lắm).</p>
<p>Phát triển: Hãy thử thay chuỗi &quot;Hello world!&quot; bằng một chuỗi khác xem. Chẳng hạn một chuỗi &quot;trái tim lấp lánh 💖&quot; chẳng hạn?</p>
<hr />
<a class="header" href="#a-làm-việc-với-giao-diện-dòng-lệnh" id="a-làm-việc-với-giao-diện-dòng-lệnh"><h2>— Làm việc với giao diện dòng lệnh</h2></a>
<p>Như yêu cầu của mình ở trên, các bạn cần phải biết một số thao tác cơ bản với dòng lệnh để có thể dễ dàng theo dõi hướng dẫn này. Nếu còn băn khoăn, đừng ngần ngại dùng Google nhé!</p>
<a class="header" href="#a-trình-biên-dịch-rust" id="a-trình-biên-dịch-rust"><h3>— Trình biên dịch Rust</h3></a>
<p>Nếu bạn đã cài đặt Rust thành công, thì:</p>
<pre><code class="language-text">$ rustc --version
rustc 1.28.0 (9634041f0 2018—07—30)
</code></pre>
<p>Ngoài lề: dấu <code>$</code> trong ví dụ trên là dấu nhắc lệnh (vui lòng không gõ luôn vào commandline :joy:).</p>
<p>Lệnh <code>rustc</code> cũng sẽ có options khác, gõ <code>rustc --help</code> để biết thêm thông tin chi tiết :D. Để compile 1 file <code>.rs</code>, chúng ta gõ (giả sử chúng ta đang compile một file <code>helloworld.rs</code> như ở trên):</p>
<pre><code class="language-text">$ rustc helloworld.rs
</code></pre>
<p>Rust không hiện thông báo lỗi nào tức là compile thành công. Ta chạy thử chương trình này bằng cách gõ:</p>
<pre><code class="language-text">$ ./helloworld
Hello world!
</code></pre>
<p>Chương trình đã thực thi thành công và in ra màn hình dòng &quot;Hello world!&quot; (như chúng ta mong muốn). Đối với Windows, đổi <code>./helloword</code> thành <code>.\helloworld</code>.
Ngoài ra, <code>rustc</code> còn có cách chế độ optimize khác nhau, nhưng mình sẽ không đề cập ở đây. Các bạn có thể tự tìm hiểu thêm thông qua Google hoặc (<code>rustc --help</code>). Vì chúng ta sẽ sử dụng một công cụ thay chúng ta làm các việc này.
Đối với một chương trình lớn, nhiều thư viện ngoài, compile bằng cách này không hay và mất thời gian. Mình sẽ hướng dẫn các bạn dùng CMake để tạo ra Makefile rồi dùng Makefilesss này compile cả dự án của bạn :joy:. Nói chứ đùa thôi, Rust toolchains đi kèm công cụ tên Cargo (như phần mở đầu có đề cập), giúp quản lý dự án của bạn khá hiệu quả.</p>
<a class="header" href="#a-i-love-cargo" id="a-i-love-cargo"><h3>— I love Cargo</h3></a>
<p>Cargo là công cụ rất hiệu quả, giúp tiết kiệm công sức của bạn. Cargo cuả Rust tương tự như nodejs có npm, ... vậy.
Phiên bản cargo mình dùng trong bài viết này là: <code>cargo 1.28.0 (96a2c7d16 2018—07—13)</code>
Cargo có các subcommands (lệnh nhỏ hơn):</p>
<pre><code class="language-text">$ # Options '--help' để xem các options và danh sách subcommands
$ cargo --help
Rust's package manager

USAGE:
    cargo [OPTIONS] [SUBCOMMAND]
&lt;đã cắt bớt ...&gt;
See 'cargo help &lt;command&gt;' for more information on a specific command.

$ # Dùng subcommand `help` để xem hướng dẫn sử dụng của từng subcommand.
$ # Ví dụ: mình muốn xem lệnh run thì gõ:
$ cargo help run
cargo—build 
Compile a local package and all of its dependencies

USAGE:
    cargo build [OPTIONS]

OPTIONS:
&lt;... đã cắt bớt ...&gt;
</code></pre>
<hr />
<p>Các subcommands mà các bạn mới học sẽ hay dùng:</p>
<ul>
<li><code>new</code>: dùng để tạo 1 project mới. Có 2 options cơ bản:
<ul>
<li><code>--bin</code>: tạo project là 1 ứng dụng thực thi (mặc định nếu bạn không dùng options nào cả). Cây thư mục có dạng: <img src="d1.cargo.new.bin+tree.png" alt="" /> File <code>src/main.rs</code> là file chính chứa hàm <code>main</code>, <code>Cargo.toml</code> là dùng để thêm các thư viện cần thiết, thay đổi version, thêm các options dành cho việc build, ...</li>
<li><code>--lib</code>: tạo project là 1 thư viện, file chính là <code>lib.rs</code> thay vì <code>main.rs</code> như ví dụ trên, hàm <code>main</code> không bắt buộc. Thư viện tạo ra có thể là thư viện Rust (<code>.rlib</code>) hay <code>.dll</code>/<code>.so</code>, ...</li>
<li>Ngoài ra, cargo còn 'init' git dùm mình. Nếu bạn không dùng git thì có thể bỏ qua.</li>
</ul>
</li>
<li><code>build</code>: dùng để ... build project. Mặc định Rust sẽ build ở mode debug và không optimize. Mode này hữu ích với bạn khi cần debug nhưng nó sẽ không nhanh.
<ul>
<li><code>--release</code>: để optimize.</li>
<li><code>—v</code> hoặc <code>--verbose</code>: có thể trong lúc build, cargo bị sản, hãy dùng option này để xem cargo đang làm gì project của mình khi build (nói chính xác là option này chỉ định cargo hiện ra chi tiết tiến trình làm việc).</li>
<li>Sau khi build, một thư mục tên là <code>target</code> sẽ được tạo, tùy vào bạn có sử dụng <code>--release</code> hay không mà sẽ có thư mục <code>debug</code> hay <code>release</code> tương ứng như hình sau: <img src="d1.cargo.run+tree.png" alt="" /></li>
</ul>
</li>
<li><code>check</code>: như <code>build</code> (cũng có <code>--release</code> và <code>--verbose</code>) nhưng chỉ check lỗi trong project, không tạo ra bất kỳ file nào (nhưng cargo vẫn sẽ tải và 'compile' các thư viện còn thiếu). Lệnh hày hữu ích khi bạn chỉ muốn xem trong project còn lỗi cú pháp nào hay không (vì thời gian compile của rustc là hơi lâu).</li>
<li><code>run</code>: như <code>build</code> (cũng có <code>--release</code> và <code>--verbose</code>) nhưng sau khi build, cargo sẽ gọi luôn file thực thi.</li>
</ul>
<hr />
<p>Trên đây là các lệnh cơ bản. Hãy dùng option <code>--help</code> và subcommand <code>help</code> để tìm hiểu thêm.</p>
<p>Một file <code>Cargo.lock</code> sẽ tạo sau lần <code>check</code>, <code>build</code>, <code>run</code> lần đầu tiên. Nó có nhiệm vụ cho phép duy nhất 1 tiến trình cargo làm việc trong 1 project, vì vậy bạn không thể 3 commandline rồi dùng 3 lệnh <code>check</code>, <code>build</code>, <code>run</code> cùng 1 lúc trên 1 project. Các tiến trình khác sẽ đợi tiến trình phía trước làm việc xong rồi mới thực thi.
Mình lưu ý thế này để khi các bạn dùng Sublime Text (+ Rust enhanced) có thể sẽ hơi hoang mang: tại sao cargo không chịu build dùm tui đi chứ? Vì khi bạn <code>Ctrl+S</code> thì Rust Enhanced sẽ chạy kiểm tra lỗi và lock file <code>Cargo.lock</code> nên cargo chưa thể build được.</p>
<hr />
<a class="header" href="#a-contributors" id="a-contributors"><h2>— Contributors:</h2></a>
<a class="header" href="#giá-trị-các-kiểu-dữ-liệu-và-khai-báo-biến" id="giá-trị-các-kiểu-dữ-liệu-và-khai-báo-biến"><h1>Giá trị, các kiểu dữ liệu và khai báo biến.</h1></a>
<a class="header" href="#cách-khai-báo-biến" id="cách-khai-báo-biến"><h2>Cách khai báo biến.</h2></a>
<p>Để khai báo biến, chúng ta sử dụng từ khóa <code>let</code> trước tên biến.
Xem đoạn code kèm comment bên dưới:</p>
<pre><pre class="playpen"><code class="language-rust">fn main(){
    // khai báo biến a với kiểu dữ liệu i32
    let a:i32; 
    
    // khai báo biến b với kiểu dữ liệu i32 và giá trị là 10
    let b:i32 = 10; 
    
    // khai báo biến c với giá trị là 10 và kiểu dữ liệu được 
    // Rust compiler tự động xác định dựa vào giá trị. 
    let c = 10;  
}
</code></pre></pre>
<p>Các biến mặc định là immutable (không thể thay đổi giá trị). Để có thể thay đổi giá trị biến chúng ta dùng từ khóa <code>mut</code>. Chi tiết xin đề cập đến ở bài sau.</p>
<p>Để in ra màn hình 1 biến chúng ta dùng <code>print!(&quot;{}&quot;, &lt;tên biến&gt;);</code> hoặc <code>println!(&quot;{}&quot;, &lt;tên biến&gt;);</code> Sẽ nói rõ hơn về chúng ở cuối bài.</p>
<pre><pre class="playpen"><code class="language-rust">fn main(){
    let a = 10;
    println!(&quot;{}&quot;, a);
}
</code></pre></pre>
<p>output:</p>
<pre><code>10
</code></pre>
<a class="header" href="#giá-trị-và-các-kiểu-dữ-liệu-cơ-bản" id="giá-trị-và-các-kiểu-dữ-liệu-cơ-bản"><h2>Giá trị và các kiểu dữ liệu cơ bản.</h2></a>
<p>Trong Rust hay các ngôn ngữ lập trình khác, các giá trị tồn tại ở các kiểu khác nhau. Ví dụ: <code>70</code> là một số nguyên(integer), <code>3.14</code> là một số thực(float), <code>z</code> và <code>A</code> là các ký tự (kiểu char,  hay character). Character là các giá trị thuộc bảng mã Unicode dài 4byte. <code>Hello world</code> là 1 chuỗi thuộc kiểu <code>&amp;str</code> (Unicode  UTF8 by default). <code>true</code> và <code>false</code> thuộc kiểu bool(Boolean).
Interger có thể được biểu diễn bằng các định dạng khác nhau:</p>
<ul>
<li>Thập lục phân (Hexadecimal) bắt đầu với <code>0x</code>. Ví dụ: <code>0x32A</code> cho 810.</li>
<li>Bát phân (Octal) bắt đầu với <code>0o</code>. Ví dụ: <code>0o1452</code> cho 810.</li>
<li>Nhị phân (Binary) bắt đầu với <code>0b</code>. Ví dụ: <code>0b1100101010</code> cho 810.</li>
</ul>
<p>Dấu gạch dưới (Underscores) <code>_</code> có thể được dùng cho dễ đọc, ví dụ 1_000_000 tương đương với 1000000.</p>
<blockquote>
<p>Các kiểu dữ liệu số trong Rust gần giống trong Golang.
Ví dụ <code>int32</code>, <code>uint32</code>, <code>int</code>, <code>uint</code> và <code>float32</code> trong Go tương đương với <code>i32</code>, <code>u32</code>, <code>isize</code>, <code>usize</code> và <code>f32</code> trong Rust.</p>
</blockquote>
<a class="header" href="#kiểu-số-nguyên-integer" id="kiểu-số-nguyên-integer"><h3>Kiểu số nguyên (Integer)</h3></a>
<p>Kiểu số nguyên trong Rust được bắt đầu bằng <code>i</code>, <code>u</code> và phía sau là kích thước (tính bằng bit) của nó. Trong đó, <code>i&lt;n&gt;</code> nghĩa là kiểu số nguyên có dấu (Signed Integer) có khoảng giá trị từ -2<sup>n-1</sup> đến 2<sup>n-1</sup>-1, <code>u&lt;n&gt;</code> là kiểu số nguyên không dấu (Unsigned Integer) có khoảng giá trị từ 0 đến 2<sup>n</sup>-1.</p>
<p>Dưới đây là các kiểu số nguyên trong Rust:
| Kích thước | Signed | Unsigned |
|--------------|---------|------------|
|8 bit         |<code>i8</code>     |<code>u8</code>        |
|16 bit        |<code>i16</code>    |<code>u16</code>       |
|32 bit        |<code>i32</code>    |<code>u32</code>       |
|64 bit        |<code>i64</code>    |<code>u64</code>       |
|128 bit       |<code>i128</code>   |<code>u128</code>      |</p>
<p>Ngoài ra, Rust còn có 2 kiểu số nguyên phụ thuộc vào kiến trúc hệ điều hành là <code>isize</code> (số nguyên có dấu) và <code>usize</code> (số nguyên không dấu). Chúng có kích thước 32 bit trong hệ thống 32 bit và 64 bit trong hệ thống 64 bit.</p>
<a class="header" href="#kiểu-số-thực-float" id="kiểu-số-thực-float"><h3>Kiểu số thực (Float)</h3></a>
<p>Trong Rust có 2 kiểu số thực là <code>f32</code> và <code>f64</code> tương đương với kích thước 32 và 64 bit.
cách khai báo</p>
<pre><pre class="playpen"><code class="language-rust">fn main(){
    let a = 3; // a thuộc kiểu integer(i32 by default), không phải float
    let b = 3.0; // b thuộc kiểu float (f64 by default)
    let c:f32 = 3; // c thuộc kiểu float(f32)
}
</code></pre></pre>
<a class="header" href="#các-phép-toán" id="các-phép-toán"><h3>Các phép toán</h3></a>
<p>Rust hỗ trợ các phép toán cơ bản sử dụng cho tất cả các kiểu dữ liệu số: cộng (addition), trừ (subtraction), nhân (multiplication), chia (division) và chia lấy phần dư (remainder).
Ví dụ:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;
    println!(&quot;{}&quot;, sum); // 15

    // subtraction
    let difference = 95.5 - 4.3;
    println!(&quot;{}&quot;, difference); // 91.2
    
    // multiplication
    let product = 4 * 30;
    println!(&quot;{}&quot;, product); // 120
    
    // division
    let quotient = 56.7 / 32.2; // float number
    let quotient2 = 56 / 32; // integer number
    println!(&quot;{}&quot;, quotient); // 1.7608695652173911
    println!(&quot;{}&quot;, quotient2); // 1
    

    // remainder
    let remainder = 43 % 5;
    println!(&quot;{}&quot;, remainder); // 3
}
</code></pre></pre>
<a class="header" href="#kiểu-luận-lý-boolean" id="kiểu-luận-lý-boolean"><h3>Kiểu luận lý (Boolean)</h3></a>
<p>Giống trong hầu hết các ngôn ngữ lập trình, kiểu <code>bool</code> trong rust có 2 giá trị là <code>true</code> và <code>false</code></p>
<pre><pre class="playpen"><code class="language-rust">fn main(){
    let a:bool = false; // khai báo `a` kiểu bool giá trị false
    let b = true; // rust compiler tự suy luận `b` thuộc kiểu bool
}
</code></pre></pre>
<a class="header" href="#kiểu-kí-tự-character" id="kiểu-kí-tự-character"><h3>Kiểu kí tự (Character)</h3></a>
<p>Kiểu <code>char</code> trong Rust được biểu diễn bên trong dấu nháy đơn <code>'</code> là các ký tự thuộc bảng mã Unicode:</p>
<pre><pre class="playpen"><code class="language-rust">fn main(){
    let a = 'a';
    let b = '😻';
    println!(&quot;{}&quot;, a);
    println!(&quot;{}&quot;, b);
}
</code></pre></pre>
<p>output:</p>
<pre><code>a
😻
</code></pre>
<a class="header" href="#kiểu-chuỗi-string" id="kiểu-chuỗi-string"><h3>Kiểu chuỗi (String)</h3></a>
<p>Trong Rust có 2 kiểu chuỗi là <code>&amp;str</code> và <code>String</code>. <code>String</code> sẽ được giới thiệu sau.</p>
<pre><pre class="playpen"><code class="language-rust">fn main(){
    let s = &quot;Hello World&quot;; // kiểu &amp;'static str ('static là lifetime, chúng ta chưa quan tâm.)
    println!(&quot;{}&quot;, s); // Hello World
}
</code></pre></pre>
<a class="header" href="#empty-type-" id="empty-type-"><h3>Empty type <code>()</code></h3></a>
<p><code>()</code> trong Rust có nghĩa là không có giá trị. Các hàm trả về kiểu <code>()</code> tương đương với các hàm không trả về giá trị. Ví dụ:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() -&gt; (){
}
</code></pre></pre>
<p>Tương đương với</p>
<pre><pre class="playpen"><code class="language-rust">fn main(){
}
</code></pre></pre>
<p><code>()</code> không tương đương với <code>null</code> trong các ngôn ngữ khác. <code>null</code> là giá trị còn <code>()</code> không phải là giá trị.</p>
<a class="header" href="#nói-thêm-về-println" id="nói-thêm-về-println"><h2>Nói thêm về <code>println!</code></h2></a>
<p><code>println!</code> tương đương với <code>print!</code> khác biệt là <code>println!</code> sẽ thêm ký tự xuống dòng ở cuối chuỗi được in ra.</p>
<p>Như các ví dụ phía trên, cách rõ nhất để biết giá trị của biến là hiển thị nó ra.</p>
<pre><pre class="playpen"><code class="language-rust">fn main(){
    let a = 10;
    println!(&quot;giá trị của biến a là: {}&quot;, a);
}
</code></pre></pre>
<p>Đối số đầu tiên của  macro <code>println!</code> là 1 chuỗi định dạng kèm theo là các <code>{}</code> (placeholder). Giá trị các hằng số hay các biến sẽ được chuyển thành chuỗi và lần lượt thay thế vào các vị trí <code>{}</code>. Ví dụ:</p>
<pre><pre class="playpen"><code class="language-rust">fn main(){
    println!(&quot;{}, {}, {}&quot;, 1, false, &quot;hello world&quot;)&quot;;
}
</code></pre></pre>
<p>output:</p>
<pre><code>1, false, hello world
</code></pre>
<p><strong>Các placeholder có thể được đánh thứ tự để sử dụng nhiều lần:</strong></p>
<pre><pre class="playpen"><code class="language-rust">fn main(){
    let name = &quot;Rust&quot;;
    let version = 1.28;
    println!(&quot;{0} là 1 ngôn ngữ lập trình dạng biên dịch. 
Phiên bản mới nhất của {0} hiện tại là {1}&quot;, name, version);
}
</code></pre></pre>
<p>output :</p>
<pre><code>Rust là 1 ngôn ngữ lập trình dạng biên dịch. 
Phiên bản mới nhất của Rust hiện tại là 1.28

</code></pre>
<p><strong>Cũng có thể đặt tên cho các đối số:</strong></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
println!(&quot;Ngôn ngữ lập trình là {name}&quot;, name = &quot;Rust&quot;);
#}</code></pre></pre>
<p>output:</p>
<pre><code>Ngôn ngữ lập trình là Rust
</code></pre>
<p><strong>Các định dạng đặc biệt có thể được biểu thị bên trong <code>{}</code> sau dấu <code>:</code></strong>
Ví dụ:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Số 18 trong hệ thập lục phân là {:0x}.&quot;, 18);
    println!(&quot;Số 18 trong hệ nhị phân là {:0b}&quot;, 18);   
    println!(&quot;Số 18 trong hệ bát phân là {:0o}&quot;, 18);
#}</code></pre></pre>
<p>output:</p>
<pre><code>Số 18 trong hệ thập lục phân là 12.
Số 18 trong hệ nhị phân là 10010
Số 18 trong hệ bát phân là 22
</code></pre>
<p>Các kiểu format như trên gồm có:</p>
<ul>
<li><code>?</code> cho mục đích debug</li>
<li><code>o</code> cho số hệ bát phân</li>
<li><code>x</code>  cho số hệ thập lục phân ở dạng viết thường</li>
<li><code>X</code>  cho số hệ thập lục phân ở dạng viết hoa</li>
<li><code>p</code> cho con trỏ (địa chỉ)</li>
<li><code>b</code> cho số hệ nhị phân</li>
<li><code>e</code> cho biểu diễn số mũ số thực dạng viết thường</li>
<li><code>E</code> cho biểu diễn số mũ số thực dạng viết hoa</li>
</ul>
<p>macro <code>format!</code> trả về giá trị kiểu <code>String</code> cũng có cách dùng tương tự với <code>println!</code>.
Xem thêm tại https://doc.rust-lang.org/std/fmt/</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
